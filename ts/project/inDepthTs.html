<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.36">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>深入TypeScript | </title><meta name="description" content="君子藏器于身 待时而动 天下有道则见 无道则隐">
    <link rel="modulepreload" href="/technology/assets/app.ee3fc36b.js"><link rel="modulepreload" href="/technology/assets/inDepthTs.html.428af5c9.js"><link rel="modulepreload" href="/technology/assets/inDepthTs.html.32b4c9ad.js"><link rel="modulepreload" href="/technology/assets/plugin-vue_export-helper.21dcd24c.js">
    <link rel="stylesheet" href="/technology/assets/style.5f6eabfb.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/technology/" class=""><img class="logo" src="https://vuejs.org/images/logo.png" alt><!----></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="技术"><span class="title">技术</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="技术"><span class="title">技术</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/technology/technology/base.md" class="" aria-label="技术前瞻"><!--[--><!--]--> 技术前瞻 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="js"><span class="title">js</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="js"><span class="title">js</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/technology/mozillajs/baseObject/symbol.md" class="" aria-label="mozilla：基本对象"><!--[--><!--]--> mozilla：基本对象 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/jsInterview/baseInterview.md" class="" aria-label="基础面试题"><!--[--><!--]--> 基础面试题 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/js/stack/executionStack.md" class="" aria-label="js 概念"><!--[--><!--]--> js 概念 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/ts/jsx/support" class="" aria-label="JSX"><!--[--><!--]--> JSX <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/ts/project/inDepthTs.md" class="" aria-label="TypeScript 项目"><!--[--><!--]--> TypeScript 项目 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/jsNews/es6News.md" class="" aria-label="js 新概念"><!--[--><!--]--> js 新概念 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="css"><span class="title">css</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="css"><span class="title">css</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/technology/mozillaCss/reference/universalSelectors.md" class="" aria-label="第 1 期：CSS API"><!--[--><!--]--> 第 1 期：CSS API <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/css/interview/baseCss.md" class="" aria-label="零散记录"><!--[--><!--]--> 零散记录 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="html"><span class="title">html</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="html"><span class="title">html</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/technology/html/interview/linkImport.md" class="" aria-label="零散记录"><!--[--><!--]--> 零散记录 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="端"><span class="title">端</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="端"><span class="title">端</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/technology/browser/interview/baseInterview.md" class="" aria-label="基础浏览器"><!--[--><!--]--> 基础浏览器 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/http/interview/baseInterview.md" class="" aria-label="基础http"><!--[--><!--]--> 基础http <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="工具"><span class="title">工具</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="工具"><span class="title">工具</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/technology/webpack/interview/webpackInterview.md" class="" aria-label="webpack"><!--[--><!--]--> webpack <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/esbuild/description.md" class="" aria-label="esbuild"><!--[--><!--]--> esbuild <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/rollup/introduction.md" class="" aria-label="rollup"><!--[--><!--]--> rollup <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/git/indx.md" class="" aria-label="git"><!--[--><!--]--> git <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/nginx/base.md" class="" aria-label="nginx"><!--[--><!--]--> nginx <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/cli/base.md" class="" aria-label="cli"><!--[--><!--]--> cli <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/npm/commonlyUsed.md" class="" aria-label="npm"><!--[--><!--]--> npm <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="react"><span class="title">react</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="react"><span class="title">react</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/technology/ILoveDevelop/react/principle/base.md" class="" aria-label="react 源码阅读 代码视角"><!--[--><!--]--> react 源码阅读 代码视角 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/react/preparation/idea.md" class="" aria-label="react 源码阅读 思想视角"><!--[--><!--]--> react 源码阅读 思想视角 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/react-illustration-series/main/macro-structure.md" class="" aria-label="图解React源码"><!--[--><!--]--> 图解React源码 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/umi/interview/pluginDva.md" class="" aria-label="umi"><!--[--><!--]--> umi <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/reactInterview/interview1.md" class="" aria-label="整理"><!--[--><!--]--> 整理 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="vue"><span class="title">vue</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="vue"><span class="title">vue</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/technology/vue/prepare/flow.md" class="" aria-label="第 1 期：源码解读-准备工作"><!--[--><!--]--> 第 1 期：源码解读-准备工作 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/vue/data-driven/_index.md" class="" aria-label="第2期：源码解读-数据驱动"><!--[--><!--]--> 第2期：源码解读-数据驱动 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/vue/components/create-component.md" class="" aria-label="第3期：源码解读-组件化"><!--[--><!--]--> 第3期：源码解读-组件化 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/vue/reactive/reactive-object.md" class="" aria-label="第4期：源码解读-深入响应式原理"><!--[--><!--]--> 第4期：源码解读-深入响应式原理 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/vue/compile/entrance.md" class="" aria-label="第5期：源码解读-编译"><!--[--><!--]--> 第5期：源码解读-编译 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/vue/extend/event.md" class="" aria-label="第6期：源码解读-扩展"><!--[--><!--]--> 第6期：源码解读-扩展 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/vue/vue-router/install.md" class="" aria-label="第7期：源码解读-VueRouter"><!--[--><!--]--> 第7期：源码解读-VueRouter <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/vue/vuex/idex.md" class="" aria-label="第8期：源码解读-Vuex"><!--[--><!--]--> 第8期：源码解读-Vuex <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/vue/interview/baseInterview.md" class="" aria-label="第9期：基础面试题"><!--[--><!--]--> 第9期：基础面试题 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="性能优化"><span class="title">性能优化</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="性能优化"><span class="title">性能优化</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/technology/performance/vue/vue2Base.md" class="" aria-label="vue-性能优化"><!--[--><!--]--> vue-性能优化 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/performance/react/reactBase.md" class="" aria-label="react-性能优化"><!--[--><!--]--> react-性能优化 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/performance/base/drag1.md" class="" aria-label="组件设计"><!--[--><!--]--> 组件设计 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="算法&amp;设计"><span class="title">算法&amp;设计</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="算法&amp;设计"><span class="title">算法&amp;设计</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/technology/algorithm/interview/baseInterview.md" class="" aria-label="第 1 期：基础面试题"><!--[--><!--]--> 第 1 期：基础面试题 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/design/overview.md" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/designFrame/jquery.md" class="" aria-label="设计应用"><!--[--><!--]--> 设计应用 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><div id="docsearch-container"></div></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="技术"><span class="title">技术</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="技术"><span class="title">技术</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/technology/technology/base.md" class="" aria-label="技术前瞻"><!--[--><!--]--> 技术前瞻 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="js"><span class="title">js</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="js"><span class="title">js</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/technology/mozillajs/baseObject/symbol.md" class="" aria-label="mozilla：基本对象"><!--[--><!--]--> mozilla：基本对象 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/jsInterview/baseInterview.md" class="" aria-label="基础面试题"><!--[--><!--]--> 基础面试题 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/js/stack/executionStack.md" class="" aria-label="js 概念"><!--[--><!--]--> js 概念 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/ts/jsx/support" class="" aria-label="JSX"><!--[--><!--]--> JSX <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/ts/project/inDepthTs.md" class="" aria-label="TypeScript 项目"><!--[--><!--]--> TypeScript 项目 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/jsNews/es6News.md" class="" aria-label="js 新概念"><!--[--><!--]--> js 新概念 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="css"><span class="title">css</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="css"><span class="title">css</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/technology/mozillaCss/reference/universalSelectors.md" class="" aria-label="第 1 期：CSS API"><!--[--><!--]--> 第 1 期：CSS API <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/css/interview/baseCss.md" class="" aria-label="零散记录"><!--[--><!--]--> 零散记录 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="html"><span class="title">html</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="html"><span class="title">html</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/technology/html/interview/linkImport.md" class="" aria-label="零散记录"><!--[--><!--]--> 零散记录 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="端"><span class="title">端</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="端"><span class="title">端</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/technology/browser/interview/baseInterview.md" class="" aria-label="基础浏览器"><!--[--><!--]--> 基础浏览器 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/http/interview/baseInterview.md" class="" aria-label="基础http"><!--[--><!--]--> 基础http <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="工具"><span class="title">工具</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="工具"><span class="title">工具</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/technology/webpack/interview/webpackInterview.md" class="" aria-label="webpack"><!--[--><!--]--> webpack <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/esbuild/description.md" class="" aria-label="esbuild"><!--[--><!--]--> esbuild <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/rollup/introduction.md" class="" aria-label="rollup"><!--[--><!--]--> rollup <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/git/indx.md" class="" aria-label="git"><!--[--><!--]--> git <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/nginx/base.md" class="" aria-label="nginx"><!--[--><!--]--> nginx <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/cli/base.md" class="" aria-label="cli"><!--[--><!--]--> cli <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/npm/commonlyUsed.md" class="" aria-label="npm"><!--[--><!--]--> npm <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="react"><span class="title">react</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="react"><span class="title">react</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/technology/ILoveDevelop/react/principle/base.md" class="" aria-label="react 源码阅读 代码视角"><!--[--><!--]--> react 源码阅读 代码视角 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/react/preparation/idea.md" class="" aria-label="react 源码阅读 思想视角"><!--[--><!--]--> react 源码阅读 思想视角 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/react-illustration-series/main/macro-structure.md" class="" aria-label="图解React源码"><!--[--><!--]--> 图解React源码 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/umi/interview/pluginDva.md" class="" aria-label="umi"><!--[--><!--]--> umi <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/reactInterview/interview1.md" class="" aria-label="整理"><!--[--><!--]--> 整理 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="vue"><span class="title">vue</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="vue"><span class="title">vue</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/technology/vue/prepare/flow.md" class="" aria-label="第 1 期：源码解读-准备工作"><!--[--><!--]--> 第 1 期：源码解读-准备工作 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/vue/data-driven/_index.md" class="" aria-label="第2期：源码解读-数据驱动"><!--[--><!--]--> 第2期：源码解读-数据驱动 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/vue/components/create-component.md" class="" aria-label="第3期：源码解读-组件化"><!--[--><!--]--> 第3期：源码解读-组件化 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/vue/reactive/reactive-object.md" class="" aria-label="第4期：源码解读-深入响应式原理"><!--[--><!--]--> 第4期：源码解读-深入响应式原理 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/vue/compile/entrance.md" class="" aria-label="第5期：源码解读-编译"><!--[--><!--]--> 第5期：源码解读-编译 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/vue/extend/event.md" class="" aria-label="第6期：源码解读-扩展"><!--[--><!--]--> 第6期：源码解读-扩展 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/vue/vue-router/install.md" class="" aria-label="第7期：源码解读-VueRouter"><!--[--><!--]--> 第7期：源码解读-VueRouter <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/vue/vuex/idex.md" class="" aria-label="第8期：源码解读-Vuex"><!--[--><!--]--> 第8期：源码解读-Vuex <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/vue/interview/baseInterview.md" class="" aria-label="第9期：基础面试题"><!--[--><!--]--> 第9期：基础面试题 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="性能优化"><span class="title">性能优化</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="性能优化"><span class="title">性能优化</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/technology/performance/vue/vue2Base.md" class="" aria-label="vue-性能优化"><!--[--><!--]--> vue-性能优化 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/performance/react/reactBase.md" class="" aria-label="react-性能优化"><!--[--><!--]--> react-性能优化 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/performance/base/drag1.md" class="" aria-label="组件设计"><!--[--><!--]--> 组件设计 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="算法&amp;设计"><span class="title">算法&amp;设计</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="算法&amp;设计"><span class="title">算法&amp;设计</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/technology/algorithm/interview/baseInterview.md" class="" aria-label="第 1 期：基础面试题"><!--[--><!--]--> 第 1 期：基础面试题 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/design/overview.md" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technology/designFrame/jquery.md" class="" aria-label="设计应用"><!--[--><!--]--> 设计应用 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading active">TypeScript 项目 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/technology/ts/project/unknownAny.html" class="sidebar-item" aria-label="TypeScript 中 unknown 与 any 有啥区别"><!--[--><!--]--> TypeScript 中 unknown 与 any 有啥区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="深入TypeScript"><!--[--><!--]--> 深入TypeScript <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#第一部分-前置内容" class="router-link-active router-link-exact-active sidebar-item" aria-label="第一部分 前置内容"><!--[--><!--]--> 第一部分 前置内容 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#extends关键词特性-重点" class="router-link-active router-link-exact-active sidebar-item" aria-label="extends关键词特性（重点）"><!--[--><!--]--> extends关键词特性（重点） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#分配条件类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="分配条件类型"><!--[--><!--]--> 分配条件类型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#类型兼容性" class="router-link-active router-link-exact-active sidebar-item" aria-label="类型兼容性"><!--[--><!--]--> 类型兼容性 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#条件类型中的类型推断" class="router-link-active router-link-exact-active sidebar-item" aria-label="条件类型中的类型推断"><!--[--><!--]--> 条件类型中的类型推断 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#第二部分-ts内置类型工具原理解析" class="router-link-active router-link-exact-active sidebar-item" aria-label="第二部分 Ts内置类型工具原理解析"><!--[--><!--]--> 第二部分 Ts内置类型工具原理解析 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#partial实现原理解析" class="router-link-active router-link-exact-active sidebar-item" aria-label="Partial实现原理解析"><!--[--><!--]--> Partial实现原理解析 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#readonly原理解析" class="router-link-active router-link-exact-active sidebar-item" aria-label="Readonly原理解析"><!--[--><!--]--> Readonly原理解析 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#pick" class="router-link-active router-link-exact-active sidebar-item" aria-label="Pick"><!--[--><!--]--> Pick <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#record" class="router-link-active router-link-exact-active sidebar-item" aria-label="Record"><!--[--><!--]--> Record <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#exclude原理解析" class="router-link-active router-link-exact-active sidebar-item" aria-label="Exclude原理解析"><!--[--><!--]--> Exclude原理解析 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#extract" class="router-link-active router-link-exact-active sidebar-item" aria-label="Extract"><!--[--><!--]--> Extract <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#omit原理解析" class="router-link-active router-link-exact-active sidebar-item" aria-label="Omit原理解析"><!--[--><!--]--> Omit原理解析 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#parameters-和-returntype" class="router-link-active router-link-exact-active sidebar-item" aria-label="Parameters 和 ReturnType"><!--[--><!--]--> Parameters 和 ReturnType <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#constructorparameters" class="router-link-active router-link-exact-active sidebar-item" aria-label="ConstructorParameters"><!--[--><!--]--> ConstructorParameters <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#ts-compiler内部实现的类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="Ts compiler内部实现的类型"><!--[--><!--]--> Ts compiler内部实现的类型 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#第三部分-自定义ts高级类型工具及类型编程技巧" class="router-link-active router-link-exact-active sidebar-item" aria-label="第三部分 自定义Ts高级类型工具及类型编程技巧"><!--[--><!--]--> 第三部分 自定义Ts高级类型工具及类型编程技巧 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#symmetricdifference" class="router-link-active router-link-exact-active sidebar-item" aria-label="SymmetricDifference"><!--[--><!--]--> SymmetricDifference <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#functionkeys" class="router-link-active router-link-exact-active sidebar-item" aria-label="FunctionKeys"><!--[--><!--]--> FunctionKeys <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#mutablekeys" class="router-link-active router-link-exact-active sidebar-item" aria-label="MutableKeys"><!--[--><!--]--> MutableKeys <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#optionalkeys" class="router-link-active router-link-exact-active sidebar-item" aria-label="OptionalKeys"><!--[--><!--]--> OptionalKeys <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#增强pick" class="router-link-active router-link-exact-active sidebar-item" aria-label="增强Pick"><!--[--><!--]--> 增强Pick <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#intersection" class="router-link-active router-link-exact-active sidebar-item" aria-label="Intersection"><!--[--><!--]--> Intersection <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#overwrite-和-assign" class="router-link-active router-link-exact-active sidebar-item" aria-label="Overwrite 和 Assign"><!--[--><!--]--> Overwrite 和 Assign <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#deeprequired" class="router-link-active router-link-exact-active sidebar-item" aria-label="DeepRequired"><!--[--><!--]--> DeepRequired <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#deepreadonlyarray" class="router-link-active router-link-exact-active sidebar-item" aria-label="DeepReadonlyArray"><!--[--><!--]--> DeepReadonlyArray <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/technology/ts/project/inDepthTs.html#uniontointersection" class="router-link-active router-link-exact-active sidebar-item" aria-label="UnionToIntersection"><!--[--><!--]--> UnionToIntersection <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></li><li><a href="/technology/ts/project/compilationContext.html" class="sidebar-item" aria-label="编译上下文"><!--[--><!--]--> 编译上下文 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/project/declarationspaces.html" class="sidebar-item" aria-label="声明空间"><!--[--><!--]--> 声明空间 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/project/modules.html" class="sidebar-item" aria-label="模块"><!--[--><!--]--> 模块 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/project/namespaces.html" class="sidebar-item" aria-label="命名空间"><!--[--><!--]--> 命名空间 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/project/dynamicImportExpressions.html" class="sidebar-item" aria-label="动态导入表达式"><!--[--><!--]--> 动态导入表达式 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading">TypeScript 类型系统 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/technology/ts/typings/overview.html" class="sidebar-item" aria-label="概览"><!--[--><!--]--> 概览 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/typings/migrating.html" class="sidebar-item" aria-label="从 JavaScript 迁移"><!--[--><!--]--> 从 JavaScript 迁移 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/typings/types.html" class="sidebar-item" aria-label="@types"><!--[--><!--]--> @types <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/typings/ambient.html" class="sidebar-item" aria-label="环境声明"><!--[--><!--]--> 环境声明 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/typings/interfaces.html" class="sidebar-item" aria-label="接口"><!--[--><!--]--> 接口 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/typings/enums.html" class="sidebar-item" aria-label="枚举"><!--[--><!--]--> 枚举 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/typings/lib.html" class="sidebar-item" aria-label="lib.d.ts"><!--[--><!--]--> lib.d.ts <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/typings/functions.html" class="sidebar-item" aria-label="函数"><!--[--><!--]--> 函数 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/typings/callable.html" class="sidebar-item" aria-label="可调用的"><!--[--><!--]--> 可调用的 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/typings/typeAssertion.html" class="sidebar-item" aria-label="类型断言"><!--[--><!--]--> 类型断言 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/typings/freshness.html" class="sidebar-item" aria-label="Freshness"><!--[--><!--]--> Freshness <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/typings/typeGuard.html" class="sidebar-item" aria-label="类型保护"><!--[--><!--]--> 类型保护 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/typings/literals.html" class="sidebar-item" aria-label="字面量类型"><!--[--><!--]--> 字面量类型 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/typings/readonly.html" class="sidebar-item" aria-label="readonly"><!--[--><!--]--> readonly <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/typings/generices.html" class="sidebar-item" aria-label="泛型"><!--[--><!--]--> 泛型 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/typings/typeInference.html" class="sidebar-item" aria-label="类型推断"><!--[--><!--]--> 类型推断 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/typings/typeCompatibility.html" class="sidebar-item" aria-label="类型兼容性"><!--[--><!--]--> 类型兼容性 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/typings/neverType.html" class="sidebar-item" aria-label="Never"><!--[--><!--]--> Never <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/typings/discrominatedUnion.html" class="sidebar-item" aria-label="辨析联合类型"><!--[--><!--]--> 辨析联合类型 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/typings/indexSignatures.html" class="sidebar-item" aria-label="索引签名"><!--[--><!--]--> 索引签名 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/typings/movingTypes.html" class="sidebar-item" aria-label="流动的类型"><!--[--><!--]--> 流动的类型 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/typings/exceptionsHanding.html" class="sidebar-item" aria-label="异常处理"><!--[--><!--]--> 异常处理 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/typings/mixins.html" class="sidebar-item" aria-label="混合"><!--[--><!--]--> 混合 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/typings/thisType.html" class="sidebar-item" aria-label="ThisType"><!--[--><!--]--> ThisType <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading">JSX <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/technology/ts/jsx/support.html" class="sidebar-item" aria-label="支持 JSX"><!--[--><!--]--> 支持 JSX <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/jsx/reactJSX.html" class="sidebar-item" aria-label="React JSX"><!--[--><!--]--> React JSX <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/jsx/nonReactJSX.html" class="sidebar-item" aria-label="非 React JSX"><!--[--><!--]--> 非 React JSX <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading">TypeScript 错误提示 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/technology/ts/error/interpreting.html" class="sidebar-item" aria-label="解读 Errors"><!--[--><!--]--> 解读 Errors <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/error/common.html" class="sidebar-item" aria-label="常见的 Error"><!--[--><!--]--> 常见的 Error <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading">TIPs <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/technology/ts/tips/stringBasedEmuns.html" class="sidebar-item" aria-label="基于字符串的枚举"><!--[--><!--]--> 基于字符串的枚举 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/tips/nominalTyping.html" class="sidebar-item" aria-label="名义化类型"><!--[--><!--]--> 名义化类型 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/tips/statefulFunctions.html" class="sidebar-item" aria-label="状态函数"><!--[--><!--]--> 状态函数 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/tips/bind.html" class="sidebar-item" aria-label="Bind 是有害的"><!--[--><!--]--> Bind 是有害的 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/tips/curry.html" class="sidebar-item" aria-label="柯里化"><!--[--><!--]--> 柯里化 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/tips/typeInstantiation.html" class="sidebar-item" aria-label="泛型的实例化类型"><!--[--><!--]--> 泛型的实例化类型 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/tips/lazyObjectLiteralInitialization.html" class="sidebar-item" aria-label="对象字面量的惰性初始化"><!--[--><!--]--> 对象字面量的惰性初始化 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/tips/classAreUseful.html" class="sidebar-item" aria-label="类是有用的"><!--[--><!--]--> 类是有用的 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/tips/avoidExportDefault.html" class="sidebar-item" aria-label="export default 被认为是有害的"><!--[--><!--]--> export default 被认为是有害的 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/tips/limitPropertySetters.html" class="sidebar-item" aria-label="减少 setter 属性的使用"><!--[--><!--]--> 减少 setter 属性的使用 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/tips/createArrays.html" class="sidebar-item" aria-label="创建数组"><!--[--><!--]--> 创建数组 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/tips/outFileCaution.html" class="sidebar-item" aria-label="谨慎使用 --outFile"><!--[--><!--]--> 谨慎使用 --outFile <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/tips/staticConstructors.html" class="sidebar-item" aria-label="TypeScript 中的静态构造函数"><!--[--><!--]--> TypeScript 中的静态构造函数 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/tips/singletonPatern.html" class="sidebar-item" aria-label="单例模式"><!--[--><!--]--> 单例模式 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/tips/functionParameters.html" class="sidebar-item" aria-label="函数参数"><!--[--><!--]--> 函数参数 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/tips/truthy.html" class="sidebar-item" aria-label="Truthy"><!--[--><!--]--> Truthy <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/tips/buildToggles.html" class="sidebar-item" aria-label="构建切换"><!--[--><!--]--> 构建切换 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/tips/typesafeEventEmitter.html" class="sidebar-item" aria-label="类型安全的 Event Emitter"><!--[--><!--]--> 类型安全的 Event Emitter <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/tips/metadata.html" class="sidebar-item" aria-label="Reflect Metadata"><!--[--><!--]--> Reflect Metadata <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/tips/covarianceAndContravariance.html" class="sidebar-item" aria-label="协变与逆变"><!--[--><!--]--> 协变与逆变 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/tips/infer.html" class="sidebar-item" aria-label="infer"><!--[--><!--]--> infer <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading">TypeScript 编译原理 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/technology/ts/compiler/overview.html" class="sidebar-item" aria-label="概览"><!--[--><!--]--> 概览 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/compiler/program.html" class="sidebar-item" aria-label="程序"><!--[--><!--]--> 程序 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/compiler/ast.html" class="sidebar-item" aria-label="抽象语法树"><!--[--><!--]--> 抽象语法树 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/compiler/scanner.html" class="sidebar-item" aria-label="扫描器"><!--[--><!--]--> 扫描器 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/compiler/parser.html" class="sidebar-item" aria-label="解析器"><!--[--><!--]--> 解析器 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/compiler/binder.html" class="sidebar-item" aria-label="绑定器"><!--[--><!--]--> 绑定器 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/compiler/checker.html" class="sidebar-item" aria-label="检查器"><!--[--><!--]--> 检查器 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/compiler/emitter.html" class="sidebar-item" aria-label="发射器"><!--[--><!--]--> 发射器 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading">TypeScript FAQs <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/technology/ts/faqs/common-bug-not-bugs.html" class="sidebar-item" aria-label="一些常见的「bug」并不是 bug"><!--[--><!--]--> 一些常见的「bug」并不是 bug <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/faqs/common-feature-request.html" class="sidebar-item" aria-label="一些常见的 Feature 需求"><!--[--><!--]--> 一些常见的 Feature 需求 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/faqs/type-system-behavior.html" class="sidebar-item" aria-label="类型系统的行为"><!--[--><!--]--> 类型系统的行为 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/faqs/function.html" class="sidebar-item" aria-label="函数"><!--[--><!--]--> 函数 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/faqs/class.html" class="sidebar-item" aria-label="类"><!--[--><!--]--> 类 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/faqs/generics.html" class="sidebar-item" aria-label="泛型"><!--[--><!--]--> 泛型 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/faqs/modules.html" class="sidebar-item" aria-label="模块"><!--[--><!--]--> 模块 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/faqs/enums.html" class="sidebar-item" aria-label="枚举"><!--[--><!--]--> 枚举 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/faqs/type-guards.html" class="sidebar-item" aria-label="类型守卫"><!--[--><!--]--> 类型守卫 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/faqs/jsx-and-react.html" class="sidebar-item" aria-label="JSX 和 React"><!--[--><!--]--> JSX 和 React <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/faqs/thing-that-dont-work.html" class="sidebar-item" aria-label="一些不能按预期工作的代码"><!--[--><!--]--> 一些不能按预期工作的代码 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/faqs/commandline-behavior.html" class="sidebar-item" aria-label="命令行的行为"><!--[--><!--]--> 命令行的行为 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/faqs/tsconfig-behavior.html" class="sidebar-item" aria-label="tsconfig.json 的行为"><!--[--><!--]--> tsconfig.json 的行为 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading">版本差异 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/technology/ts/new/typescript-3.9.html" class="sidebar-item" aria-label="TypeScript 3.9"><!--[--><!--]--> TypeScript 3.9 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/new/typescript-3.8.html" class="sidebar-item" aria-label="TypeScript 3.8"><!--[--><!--]--> TypeScript 3.8 <!--[--><!--]--></a><!----></li><li><a href="/technology/ts/new/typescript-3.7.html" class="sidebar-item" aria-label="TypeScript 3.7"><!--[--><!--]--> TypeScript 3.7 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="深入typescript" tabindex="-1"><a class="header-anchor" href="#深入typescript" aria-hidden="true">#</a> 深入TypeScript</h1><h2 id="第一部分-前置内容" tabindex="-1"><a class="header-anchor" href="#第一部分-前置内容" aria-hidden="true">#</a> 第一部分 前置内容</h2><ul><li><code>keyof</code> 索引查询</li></ul><p>对应任何类型<code>T</code>,<code>keyof T</code>的结果为该类型上所有共有属性key的联合：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Eg1</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
  <span class="token keyword">readonly</span> age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token comment">// T1的类型实则是name | age</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> <span class="token keyword">keyof</span> Eg1

<span class="token keyword">class</span> <span class="token class-name">Eg2</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">readonly</span> age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token keyword">protected</span> home<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// T2实则被约束为 age</span>
<span class="token comment">// 而name和home不是公有属性，所以不能被keyof获取到</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token operator">=</span> <span class="token keyword">keyof</span> Eg2
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><ul><li><code>T[K]</code> 索引访问</li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Eg1</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
  <span class="token keyword">readonly</span> age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">V1</span></span> <span class="token operator">=</span> Eg1<span class="token punctuation">[</span><span class="token string">&#39;name&#39;</span><span class="token punctuation">]</span>
<span class="token comment">// string | number</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">V2</span></span> <span class="token operator">=</span> Eg1<span class="token punctuation">[</span><span class="token string">&#39;name&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;age&#39;</span><span class="token punctuation">]</span>
<span class="token comment">// any</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">V2</span></span> <span class="token operator">=</span> Eg1<span class="token punctuation">[</span><span class="token string">&#39;name&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;age2222&#39;</span><span class="token punctuation">]</span>
<span class="token comment">// string | number</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">V3</span></span> <span class="token operator">=</span> Eg1<span class="token punctuation">[</span><span class="token keyword">keyof</span> Eg1<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><code>T[keyof T]</code>的方式，可以获取到<code>T</code>所有<code>key</code>的类型组成的联合类型；<code>T[keyof K]</code>的方式，获取到的是<code>T</code>中的<code>key</code>且同时存在于<code>K</code>时的类型组成的联合类型；注意：如果<code>[]</code>中的<code>key</code>有不存在<code>T</code>中的，则是<code>any</code>；因为<code>ts</code>也不知道该<code>key</code>最终是什么类型，所以是<code>any</code>；且也会报错；</p><ul><li><code>&amp;</code> 交叉类型注意点</li></ul><p>交叉类型取的多个类型的并集，但是如果相同<code>key</code>但是类型不同，则该<code>key</code>为<code>never</code>。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Eg1</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Eg2</span> <span class="token punctuation">{</span>
  color<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * T的类型为 <span class="token punctuation">{</span>name: string; age: number; age: never<span class="token punctuation">}</span>
 * 注意，age因为Eg1和Eg2中的类型不一致，所以交叉后age的类型是never
 */</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T</span></span> <span class="token operator">=</span> Eg1 <span class="token operator">&amp;</span> Eg2
<span class="token comment">// 可通过如下示例验证</span>
<span class="token keyword">const</span> val<span class="token operator">:</span> <span class="token constant">T</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">,</span>
  color<span class="token operator">:</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h3 id="extends关键词特性-重点" tabindex="-1"><a class="header-anchor" href="#extends关键词特性-重点" aria-hidden="true">#</a> extends关键词特性（重点）</h3><ul><li>用于接口，表示继承</li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token punctuation">{</span>
  sex<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@example</span>
 * T3 = <span class="token punctuation">{</span>name: string, sex: number, age: number<span class="token punctuation">}</span>
 */</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">T3</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">T1</span></span><span class="token punctuation">,</span> <span class="token constant">T2</span> <span class="token punctuation">{</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>注意，接口支持多重继承，语法为逗号隔开。如果是<code>type</code>实现继承，则可以使用交叉类型<code>type A = B &amp; C &amp; D</code>。</p><ul><li>表示条件类型，可用于条件判断</li></ul><p>表示条件判断，如果前面的条件满足，则返回问号后的第一个参数，否则第二个。类似于js的三元运算。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@example</span>
 * type A1 = 1
 */</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A1</span></span> <span class="token operator">=</span> <span class="token string">&#39;x&#39;</span> <span class="token keyword">extends</span> <span class="token string">&#39;x&#39;</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@example</span>
 * type A2 = 2
 */</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A2</span></span> <span class="token operator">=</span> <span class="token string">&#39;x&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;y&#39;</span> <span class="token keyword">extends</span> <span class="token string">&#39;x&#39;</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@example</span>
 * type A3 = 1 | 2
 */</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">P</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token string">&#39;x&#39;</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A3</span></span> <span class="token operator">=</span> <span class="token constant">P</span><span class="token operator">&lt;</span><span class="token string">&#39;x&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;y&#39;</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>提问：为什么<code>A2</code>和<code>A3</code>的值不一样？</p><ul><li><p>如果用于简单的条件判断，则是直接判断前面的类型是否可分配给后面的类型</p></li><li><p>若<code>extends</code>前面的类型是泛型，且泛型传入的是联合类型时，则会依次判断该联合类型的所有子类型是否可分配给<code>extends</code>后面的类型（是一个分发的过程）。</p></li></ul><p><strong>总结，就是<code>extends</code>前面的参数为联合类型时则会分解（依次遍历所有的子类型进行条件判断）联合类型进行判断。然后将最终的结果组成新的联合类型。</strong></p><ul><li>阻止<code>extends</code>关键词对于联合类型的分发特性</li></ul><p>如果不想被分解（分发），做法也很简单，可以通过简单的元组类型包裹以下：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">P</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token string">&#39;x&#39;</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token doc-comment comment">/**
 * type A4 = 2;
 */</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A4</span></span> <span class="token operator">=</span> <span class="token constant">P</span><span class="token operator">&lt;</span><span class="token string">&#39;x&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;y&#39;</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="分配条件类型" tabindex="-1"><a class="header-anchor" href="#分配条件类型" aria-hidden="true">#</a> 分配条件类型</h3><p>当条件类型作用于泛型类型时，当给定联合类型时，它们会变成分布式的。例如，采取以下措施：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">ToArray<span class="token operator">&lt;</span>Type<span class="token operator">&gt;</span></span> <span class="token operator">=</span> Type <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span> <span class="token operator">?</span> Type<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>如果将联合类型插入<code>ToArray</code>，则条件类型将应用于该联合的每个成员。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">ToArray<span class="token operator">&lt;</span>Type<span class="token operator">&gt;</span></span> <span class="token operator">=</span> Type <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span> <span class="token operator">?</span> Type<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
 
<span class="token keyword">type</span> <span class="token class-name">StrArrOrNumArr</span> <span class="token operator">=</span> ToArray<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token comment">// type StrArrOrNumArr = string[] | number[]</span>
<span class="token comment">// type ToArray&lt;type&gt; = Type extends any ? Type[] : never</span>
<span class="token comment">// (type parameter) Type in type ToArray&lt;Type&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这里发生的是<code>StrOrNumArray</code>分布于：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>并映射到联合的每个成员类型，有效地：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>ToArray<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span> <span class="token operator">|</span> ToArray<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token comment">// type ToArray&lt;type&gt; = Type extends any ? Type[] : never</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这给留下了：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>通常，分配性是所需的行为。为避免这种行为，您可以<code>extends</code>用方括号将关键字的每一侧括起来。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">ToArrayNonDist<span class="token operator">&lt;</span>Type<span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">[</span>Type<span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token builtin">any</span><span class="token punctuation">]</span> <span class="token operator">?</span> Type<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
 
<span class="token comment">// &#39;StrOrNumArr&#39; is no longer a union.</span>
<span class="token keyword">type</span> <span class="token class-name">StrOrNumArr</span> <span class="token operator">=</span> ToArrayNonDist<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token comment">// type StrOrNumArr = (string | number)[]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="类型兼容性" tabindex="-1"><a class="header-anchor" href="#类型兼容性" aria-hidden="true">#</a> 类型兼容性</h3><blockquote><p>集合论中，如果一个集合的所有元素在集合B中都存在，则A是B的子集； 类型系统中，如果一个类型的属性更具体，则该类型是子类型。（因为属性更少则说明该类型约束的更宽泛，是父类型）</p></blockquote><p><strong>因此，可以得出基本的结论：子类型比父类型更加具体,父类型比子类型更宽泛。</strong> 下面也将基于类型的可复制性（可分配性）、协变、逆变、双向协变等进行进一步的讲解。</p><ul><li>可赋值性</li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token keyword">break</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> a<span class="token operator">:</span> Animal<span class="token punctuation">;</span>
<span class="token keyword">let</span> b<span class="token operator">:</span> Dog<span class="token punctuation">;</span>

<span class="token comment">// 可以赋值，子类型更佳具体，可以赋值给更佳宽泛的父类型</span>
a <span class="token operator">=</span> b<span class="token punctuation">;</span>
<span class="token comment">// 反过来不行</span>
b <span class="token operator">=</span> a<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><ul><li>可赋值性在联合类型中的特性</li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> a<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> b<span class="token operator">:</span> <span class="token constant">B</span><span class="token punctuation">;</span>

<span class="token comment">// 不可赋值</span>
b <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token comment">// 可以赋值</span>
a <span class="token operator">=</span> b<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>是不是<code>A</code>的类型更多，<code>A</code>就是子类型呢？恰恰相反，<code>A</code>此处类型更多但是其表达的类型更宽泛，所以<code>A</code>是父类型，<code>B</code>是子类型。</p><p>因此<code>b = a</code>不成立（父类型不能赋值给子类型），而<code>a = b</code>成立（子类型可以赋值给父类型）。</p><ul><li>协变</li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token keyword">break</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> Eg1<span class="token operator">:</span> Animal<span class="token punctuation">;</span>
<span class="token keyword">let</span> Eg2<span class="token operator">:</span> Dog<span class="token punctuation">;</span>
<span class="token comment">// 兼容，可以赋值</span>
Eg1 <span class="token operator">=</span> Eg2<span class="token punctuation">;</span>

<span class="token keyword">let</span> Eg3<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span>Animal<span class="token operator">&gt;</span>
<span class="token keyword">let</span> Eg4<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span>Dog<span class="token operator">&gt;</span>
<span class="token comment">// 兼容，可以赋值</span>
Eg3 <span class="token operator">=</span> Eg4
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>通过<code>Eg3</code>和<code>Eg4</code>来看，在<code>Animal</code>和<code>Dog</code>在变成数组后，<code>Array&lt;Dog&gt;</code>依旧可以赋值给<code>Array&lt;Animal&gt;</code>，因此对于<code>type MakeArray = Array&lt;any&gt;</code>来说就是协变的。</p><p>最后引用维基百科中的定义：</p><blockquote><p>协变与逆变(Covariance and contravariance )是在计算机科学中，描述具有父/子型别关系的多个型别通过型别构造器、构造出的多个复杂型别之间是否有父/子型别关系的用语。</p></blockquote><p>简单说就是，具有父子关系的多个类型，在通过某种构造关系构造成的新的类型，如果还具有父子关系则是协变的，而关系逆转了（子变父，父变子）就是逆变的。可能听起来有些抽象，下面将用更具体的例子进行演示说明：</p><ul><li>逆变</li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token keyword">break</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">AnimalFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> Animal<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>
<span class="token keyword">type</span> <span class="token class-name">DogFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> Dog<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>

<span class="token keyword">let</span> Eg1<span class="token operator">:</span> AnimalFn<span class="token punctuation">;</span>
<span class="token keyword">let</span> Eg2<span class="token operator">:</span> DogFn<span class="token punctuation">;</span>
<span class="token comment">// 不再可以赋值了，</span>
<span class="token comment">// AnimalFn = DogFn不可以赋值了, Animal = Dog是可以的</span>
Eg1 <span class="token operator">=</span> Eg2<span class="token punctuation">;</span>
<span class="token comment">// 反过来可以</span>
Eg2 <span class="token operator">=</span> Eg1<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>理论上，<code>Animal = Dog</code>是类型安全的，那么<code>AnimalFn = DogFn</code>也应该类型安全才对，为什么Ts认为不安全呢？看下面的例子：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">let</span> animal<span class="token operator">:</span> <span class="token function-variable function">AnimalFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> Animal<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> dog<span class="token operator">:</span> <span class="token function-variable function">DogFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> Dog<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  arg<span class="token punctuation">.</span><span class="token function">break</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 假设类型安全可以赋值</span>
animal <span class="token operator">=</span> dog<span class="token punctuation">;</span>
<span class="token comment">// 那么animal在调用时约束的参数，缺少dog所需的参数，此时会导致错误</span>
<span class="token function">animal</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">&#39;cat&#39;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>从这个例子看到，如果dog函数赋值给animal函数，那么animal函数在调用时，约束的是参数必须要为Animal类型（而不是Dog），但是animal实际为dog的调用，此时就会出现错误。</p><p>因此，<code>Animal</code>和<code>Dog</code>在进行<code>type Fn&lt;T&gt; = (arg: T) =&gt; void</code>构造器构造后，父子关系逆转了，此时成为“逆变”。</p><ul><li>双向协变</li></ul><p>Ts在函数参数的比较中实际上默认采取的策略是双向协变：只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。</p><p>这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了不是那么精确的类型信息（典型的就是上述的逆变）。 但是实际上，这极少会发生错误，并且能够实现很多JavaScript里的常见模式：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// lib.dom.d.ts中EventListener的接口定义</span>
<span class="token keyword">interface</span> <span class="token class-name">EventListener</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span>evt<span class="token operator">:</span> Event<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 简化后的Event</span>
<span class="token keyword">interface</span> <span class="token class-name">Event</span> <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> target<span class="token operator">:</span> EventTarget <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 简化合并后的MouseEvent</span>
<span class="token keyword">interface</span> <span class="token class-name">MouseEvent</span> <span class="token keyword">extends</span> <span class="token class-name">Event</span> <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token keyword">readonly</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 简化后的Window接口</span>
<span class="token keyword">interface</span> <span class="token class-name">Window</span> <span class="token punctuation">{</span>
  <span class="token comment">// 简化后的addEventListener</span>
  <span class="token function">addEventListener</span><span class="token punctuation">(</span>type<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> listener<span class="token operator">:</span> EventListener<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 日常使用</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;click&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Event<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;mouseover&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> MouseEvent<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>可以看到<code>Window</code>的<code>listener</code>函数要求参数是<code>Event</code>，但是日常使用时更多时候传入的是<code>Event</code>子类型。但是这里可以正常使用，正是其默认行为是双向协变的原因。可以通过<code>tsconfig.js</code>中修改<code>strictFunctionType</code>属性来严格控制协变和逆变。</p><p><code>infer</code>关键词的功能暂时先不做太详细的说明了，主要是用于<code>extends</code>的条件类型中让Ts自己推到类型，具体的可以查阅官网。但是关于<code>infer</code>的一些容易让人忽略但是非常重要的特性，这里必须要提及一下：</p><ul><li><code>infer</code>推导的名称相同并且都处于<strong>逆变</strong>的位置，则推导的结果将会是<strong>交叉类型</strong>。</li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Bar<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">U</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">U</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token operator">?</span> <span class="token constant">U</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>

<span class="token comment">// type T1 = string</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> Bar<span class="token operator">&lt;</span><span class="token punctuation">{</span> <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token comment">// type T2 = never</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token operator">=</span> Bar<span class="token operator">&lt;</span><span class="token punctuation">{</span> <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="条件类型中的类型推断" tabindex="-1"><a class="header-anchor" href="#条件类型中的类型推断" aria-hidden="true">#</a> 条件类型中的类型推断</h3><p>在<code>extends</code>条件类型的子句中，现在可以有<code>infer</code>引入要推断的类型变量的声明。可以在条件类型的真实分支中引用此类推断类型变量。<code>infer</code>同一个类型变量可以有多个位置。</p><p>例如，以下提取函数类型的返回类型：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">ReturnType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">infer</span> <span class="token constant">R</span> <span class="token operator">?</span> <span class="token constant">R</span> <span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>条件类型可以嵌套以形成按顺序评估的模式匹配序列：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Unpacked<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token keyword">infer</span> <span class="token constant">U</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token operator">?</span> <span class="token constant">U</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">infer</span> <span class="token constant">U</span>
  <span class="token operator">?</span> <span class="token constant">U</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">infer</span> <span class="token constant">U</span><span class="token operator">&gt;</span></span>
  <span class="token operator">?</span> <span class="token constant">U</span>
  <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T0</span></span> <span class="token operator">=</span> Unpacked<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> Unpacked<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token operator">=</span> Unpacked<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T3</span></span> <span class="token operator">=</span> Unpacked<span class="token operator">&lt;</span><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T4</span></span> <span class="token operator">=</span> Unpacked<span class="token operator">&lt;</span><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// Promise&lt;string&gt;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T5</span></span> <span class="token operator">=</span> Unpacked<span class="token operator">&lt;</span>Unpacked<span class="token operator">&lt;</span><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>以下示例演示了协变位置中同一类型变量的多个候选者如何导致推断联合类型：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Foo<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">U</span><span class="token punctuation">;</span> b<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">U</span> <span class="token punctuation">}</span> <span class="token operator">?</span> <span class="token constant">U</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T10</span></span> <span class="token operator">=</span> Foo<span class="token operator">&lt;</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> b<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T11</span></span> <span class="token operator">=</span> Foo<span class="token operator">&lt;</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> b<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string | number</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>同样，逆变位置中同一类型变量的多个候选会导致推断出交叉类型：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Bar<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span> <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">U</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">U</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span> <span class="token punctuation">}</span>
  <span class="token operator">?</span> <span class="token constant">U</span>
  <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T20</span></span> <span class="token operator">=</span> Bar<span class="token operator">&lt;</span><span class="token punctuation">{</span> <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T21</span></span> <span class="token operator">=</span> Bar<span class="token operator">&lt;</span><span class="token punctuation">{</span> <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string &amp; number</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>当从具有多个调用签名的类型（例如重载函数的类型）进行推断时，会从最后一个签名（这可能是最宽松的包罗万象的情况）进行推断。无法根据参数类型列表执行重载决议。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T30</span></span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token keyword">typeof</span> foo<span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string | number</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>不能<code>infer</code>在常规类型参数的约束子句中使用声明：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">ReturnType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span></span> <span class="token keyword">infer</span> <span class="token constant">R</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">;</span> <span class="token comment">// Error, not supported</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>但是，通过删除约束中的类型变量并指定条件类型，可以获得大致相同的效果：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">AnyFunction</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">ReturnType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> AnyFunction<span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">infer</span> <span class="token constant">R</span>
  <span class="token operator">?</span> <span class="token constant">R</span>
  <span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="第二部分-ts内置类型工具原理解析" tabindex="-1"><a class="header-anchor" href="#第二部分-ts内置类型工具原理解析" aria-hidden="true">#</a> 第二部分 Ts内置类型工具原理解析</h2><h3 id="partial实现原理解析" tabindex="-1"><a class="header-anchor" href="#partial实现原理解析" aria-hidden="true">#</a> Partial实现原理解析</h3><p><code>Partial&lt;T&gt;</code>将<code>T</code>的所有属性变成可选的。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * 核心实现就是通过映射类型遍历T上所有的属性，
 * 然后将每个属性设置为可选属性
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Partial<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li><p><code>[P in keyof T]</code>通过映射类型，遍历<code>T</code>上的所有属性</p></li><li><p><code>?:</code>设置为属性为可选的</p></li><li><p><code>T[P]</code>设置类型为原来的类型</p></li></ul><p>扩展一下，将制定的<code>key</code>变成可选类型:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * 主要通过K extends keyof T约束K必须为keyof T的子类型
 * keyof T得到的是T的所有key组成的联合类型
 */</span>
<span class="token keyword">type</span> <span class="token class-name">PartialOptional<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@example</span>
 *     type Eg1 = <span class="token punctuation">{</span> key1?: string; key2?: number <span class="token punctuation">}</span>
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg1</span> <span class="token operator">=</span> PartialOptional<span class="token operator">&lt;</span><span class="token punctuation">{</span>
  key1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
  key2<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
  key3<span class="token operator">:</span> <span class="token string">&#39;&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&#39;key1&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;key2&#39;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h3 id="readonly原理解析" tabindex="-1"><a class="header-anchor" href="#readonly原理解析" aria-hidden="true">#</a> Readonly原理解析</h3><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * 主要实现是通过映射遍历所有key，
 * 然后给每个key增加一个readonly修饰符
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Readonly<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@example</span>
 * type Eg = <span class="token punctuation">{</span>
 *   readonly key1: string;
 *   readonly key2: number;
 * <span class="token punctuation">}</span>
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> Readonly<span class="token operator">&lt;</span><span class="token punctuation">{</span>
  key1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
  key2<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h3 id="pick" tabindex="-1"><a class="header-anchor" href="#pick" aria-hidden="true">#</a> Pick</h3><p>挑选一组属性并组成一个新的类型。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>基本和上述同样的知识点，就不再赘述了。</p><h3 id="record" tabindex="-1"><a class="header-anchor" href="#record" aria-hidden="true">#</a> Record</h3><p>构造一个<code>type</code>，<code>key</code>为联合类型中的每个子类型，类型为<code>T</code>。文字不好理解，先看例子：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@example</span>
 * type Eg1 = <span class="token punctuation">{</span>
 *   a: <span class="token punctuation">{</span> key1: string; <span class="token punctuation">}</span>;
 *   b: <span class="token punctuation">{</span> key1: string; <span class="token punctuation">}</span>;
 * <span class="token punctuation">}</span>
 * <span class="token keyword">@desc</span> 就是遍历第一个参数&#39;a&#39; | &#39;b&#39;的每个子类型，然后将值设置为第二参数
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg1</span> <span class="token operator">=</span> Record<span class="token operator">&lt;</span><span class="token string">&#39;a&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>key1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>Record具体实现：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * 核心实现就是遍历K，将值设置为T
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Record<span class="token operator">&lt;</span><span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@example</span>
 * type Eg2 = <span class="token punctuation">{</span>a: B, b: B<span class="token punctuation">}</span>
 */</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
  b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token punctuation">{</span>
  key1<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
  key2<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">Eg2</span> <span class="token operator">=</span> Record<span class="token operator">&lt;</span><span class="token keyword">keyof</span> <span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><ul><li><p>值得注意的是<code>keyof any</code>得到的是<code>string | number | symbol</code></p></li><li><p>原因在于类型key的类型只能为<code>string | number | symbol</code></p></li></ul><p><strong>扩展: 同态与非同态</strong></p><ul><li><code>Partial</code>、<code>Readonly</code>和<code>Pick</code>都属于同态的，即其实现需要输入类型T来拷贝属性，因此属性修饰符（例如readonly、?:）都会被拷贝。可从下面例子验证：</li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@example</span>
 * type Eg = <span class="token punctuation">{</span>readonly a?: string<span class="token punctuation">}</span>
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span><span class="token punctuation">{</span><span class="token keyword">readonly</span> a<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&#39;a&#39;</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>从<code>Eg</code>的结果可以看到，Pick在拷贝属性时，连带拷贝了<code>readonly</code>和<code>?:</code>的修饰符。</p><ul><li><code>Record</code>是非同态的，不需要拷贝属性，因此不会拷贝属性修饰符</li></ul><p>为什么<code>Pick</code>拷贝了属性，而<code>Record</code>没有拷贝？来对比一下其实现：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">Record<span class="token operator">&lt;</span><span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>可以看到<code>Pick</code>的实现中，注意<code>P in K</code>（本质是<code>P in keyof T</code>），T为输入的类型，而<code>keyof T</code>则遍历了输入类型；而<code>Record</code>的实现中，并没有遍历所有输入的类型，K只是约束为<code>keyof any</code>的子类型即可。</p><p>最后再类比一下<code>Pick</code>、<code>Partial</code>、<code>readonly</code>这几个类型工具，无一例外，都是使用到了<code>keyof T</code>来辅助拷贝传入类型的属性。</p><h3 id="exclude原理解析" tabindex="-1"><a class="header-anchor" href="#exclude原理解析" aria-hidden="true">#</a> Exclude原理解析</h3><p><code>Exclude&lt;T, U&gt;</code>提取存在于<code>T</code>，但不存在于<code>U</code>的类型组成的联合类型。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * 遍历T中的所有子类型，如果该子类型约束于U（存在于U、兼容于U），
 * 则返回never类型，否则返回该子类型
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Exclude<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">U</span></span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@example</span>
 * type Eg = &#39;key1&#39;
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> Exclude<span class="token operator">&lt;</span><span class="token string">&#39;key1&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;key2&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;key2&#39;</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><ul><li><p><code>never</code>表示一个不存在的类型</p></li><li><p><code>never</code>与其他类型的联合后，是没有<code>never</code>的</p></li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@example</span>
 * type Eg2 = string | number
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg2</span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">never</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>因此上述<code>Eg</code>其实就等于<code>key1 | never</code>,也就是<code>type Eg = key1</code></p><h3 id="extract" tabindex="-1"><a class="header-anchor" href="#extract" aria-hidden="true">#</a> Extract</h3><p><code>Extract&lt;T, U&gt;</code>提取联合类型T和联合类型U的所有交集。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Extract<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">U</span></span> <span class="token operator">?</span> <span class="token constant">T</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@example</span>
 *  type Eg = &#39;key1&#39;
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> Extract<span class="token operator">&lt;</span><span class="token string">&#39;key1&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;key2&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;key1&#39;</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="omit原理解析" tabindex="-1"><a class="header-anchor" href="#omit原理解析" aria-hidden="true">#</a> Omit原理解析</h3><p><code>Omit&lt;T, K&gt;</code>从类型<code>T</code>中剔除<code>K</code>中的所有属性。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * 利用Pick实现Omit
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Omit</span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> Exclude<span class="token operator">&lt;</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><p>换种思路想一下，其实现可以是利用<code>Pick</code>提取我们需要的keys组成的类型</p></li><li><p>因此也就是 <code>Omit = Pick&lt;T, 我们需要的属性联合&gt;</code></p></li><li><p>而我们需要的属性联合就是，从T的属性联合中排出存在于联合类型K中的</p></li><li><p>因此也就是<code>Exclude&lt;keyof T, K&gt;</code>;</p></li></ul><p>如果不利用Pick实现呢?</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * 利用映射类型Omit
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Omit2<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token builtin">any</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> Exclude<span class="token operator">&lt;</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li><p>其实现类似于<code>Pick</code>的原理实现</p></li><li><p>区别在于是遍历的我们需要的属性不一样</p></li><li><p>我们需要的属性和上面的例子一样，就是<code>Exclude&lt;keyof T, K&gt;</code></p></li><li><p>因此，遍历就是<code>[P in Exclude&lt;keyof T, K&gt;]</code></p></li></ul><h3 id="parameters-和-returntype" tabindex="-1"><a class="header-anchor" href="#parameters-和-returntype" aria-hidden="true">#</a> Parameters 和 ReturnType</h3><p><strong>Parameters 获取函数的参数类型，将每个参数类型放在一个元组中。</strong></p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@desc</span> 具体实现
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Parameters<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span></span> <span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">P</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">any</span> <span class="token operator">?</span> <span class="token constant">P</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@example</span>
 * type Eg = [arg1: string, arg2: number];
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> Parameters<span class="token operator">&lt;</span><span class="token punctuation">(</span>arg1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> arg2<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><ul><li><p><code>Parameters</code>首先约束参数<code>T</code>必须是个函数类型，所以<code>(...args: any) =&gt; any&gt;</code>替换成<code>Function</code>也是可以的</p></li><li><p>具体实现就是，判断<code>T</code>是否是函数类型，如果是则使用<code>inter P</code>让ts自己推导出函数的参数类型，并将推导的结果存到类型<code>P</code>上，否则就返回<code>never</code>；</p></li></ul><blockquote><ul><li><p><code>infer</code>关键词作用是让Ts自己推导类型，并将推导结果存储在其参数绑定的类型上。Eg:<code>infer P</code> 就是将结果存在类型<code>P</code>上，供使用。</p></li><li><p><code>infer</code>关键词只能在<code>extends</code>条件类型上使用，不能在其他地方使用。</p></li></ul></blockquote><p><strong>注意</strong></p><ul><li><p><code>type Eg = [arg1: string, arg2: number]</code>这是一个元组，但是和我们常见的元组<code>type tuple = [string, number]</code>。官网未提到该部分文档说明，其实可以把这个作为类似命名元组，或者具名元组的意思去理解。实质上没有什么特殊的作用，比如无法通过这个具名去取值不行的。但是从语义化的角度，个人觉得多了语义化的表达罢了。</p></li><li><p>定义元祖的可选项，只能是最后的选项</p></li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * 普通方式
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Tuple1</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">?</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> a<span class="token operator">:</span> Tuple1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;aa&#39;</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> a2<span class="token operator">:</span> Tuple1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;aa&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * 具名方式
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Tuple2</span> <span class="token operator">=</span> <span class="token punctuation">[</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> age<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> b<span class="token operator">:</span> Tuple2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;aa&#39;</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> b2<span class="token operator">:</span> Tuple2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;aa&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>扩展：<code>infer</code>实现一个推导数组所有元素的类型：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * 约束参数T为数组类型，
 * 判断T是否为数组，如果是数组类型则推导数组元素的类型
 */</span>
<span class="token keyword">type</span> <span class="token class-name">FalttenArray<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token keyword">infer</span> <span class="token constant">P</span><span class="token operator">&gt;</span></span> <span class="token operator">?</span> <span class="token constant">P</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * type Eg1 = number | string;
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg1</span> <span class="token operator">=</span> FalttenArray<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>
<span class="token doc-comment comment">/**
 * type Eg2 = 1 | &#39;asd&#39;;
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg2</span> <span class="token operator">=</span> FalttenArray<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&#39;asd&#39;</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><strong>ReturnType 获取函数的返回值类型。</strong></p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@desc</span> ReturnType的实现其实和Parameters的基本一样
 * 无非是使用infer R的位置不一样。
 */</span>
<span class="token keyword">type</span> <span class="token class-name">ReturnType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span></span> <span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">infer</span> <span class="token constant">R</span> <span class="token operator">?</span> <span class="token constant">R</span> <span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="constructorparameters" tabindex="-1"><a class="header-anchor" href="#constructorparameters" aria-hidden="true">#</a> ConstructorParameters</h3><p><code>ConstructorParameters</code>可以获取类的构造函数的参数类型，存在一个元组中。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * 核心实现还是利用infer进行推导构造函数的参数类型
 */</span>
<span class="token keyword">type</span> <span class="token class-name">ConstructorParameters<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token keyword">abstract</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span></span> <span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token keyword">abstract</span></span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">P</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">any</span> <span class="token operator">?</span> <span class="token constant">P</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>


<span class="token doc-comment comment">/**
 * <span class="token keyword">@example</span>
 * type Eg = string;
 */</span>
<span class="token keyword">interface</span> <span class="token class-name">ErrorConstructor</span> <span class="token punctuation">{</span>
  <span class="token keyword">new</span><span class="token punctuation">(</span>message<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> Error<span class="token punctuation">;</span>
  <span class="token punctuation">(</span>message<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> Error<span class="token punctuation">;</span>
  <span class="token keyword">readonly</span> prototype<span class="token operator">:</span> Error<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> ConstructorParameters<span class="token operator">&lt;</span>ErrorConstructor<span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@example</span>
 * type Eg2 = [name: string, sex?: number];
 */</span>
<span class="token keyword">class</span> <span class="token class-name">People</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">public</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> sex<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">Eg2</span> <span class="token operator">=</span> ConstructorParameters<span class="token operator">&lt;</span><span class="token keyword">typeof</span> People<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><ul><li><p>首先约束参数<code>T</code>为拥有构造函数的类。注意这里有个<code>abstract</code>修饰符，等下会说明。</p></li><li><p>实现时，判断<code>T</code>是满足约束的类时，利用<code>infer P</code>自动推导构造函数的参数类型，并最终返回该类型。</p></li></ul><h4 id="那么疑问来了-为什么要对t要约束为abstract抽象类呢-看下面例子" tabindex="-1"><a class="header-anchor" href="#那么疑问来了-为什么要对t要约束为abstract抽象类呢-看下面例子" aria-hidden="true">#</a> 那么疑问来了，为什么要对T要约束为abstract抽象类呢？看下面例子：</h4><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * 定义一个普通类
 */</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token doc-comment comment">/**
 * 定义一个抽象类
 */</span>
<span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">MyAbstractClass</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 可以赋值</span>
<span class="token keyword">const</span> c1<span class="token operator">:</span> <span class="token keyword">typeof</span> MyClass <span class="token operator">=</span> MyClass
<span class="token comment">// 报错，无法将抽象构造函数类型分配给非抽象构造函数类型</span>
<span class="token keyword">const</span> c2<span class="token operator">:</span> <span class="token keyword">typeof</span> MyClass <span class="token operator">=</span> MyAbstractClass

<span class="token comment">// 可以赋值</span>
<span class="token keyword">const</span> c3<span class="token operator">:</span> <span class="token keyword">typeof</span> MyAbstractClass <span class="token operator">=</span> MyClass
<span class="token comment">// 可以赋值</span>
<span class="token keyword">const</span> c4<span class="token operator">:</span> <span class="token keyword">typeof</span> MyAbstractClass <span class="token operator">=</span> MyAbstractClass
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>由此看出，如果将类型定义为抽象类（抽象构造函数），则既可以赋值为抽象类，也可以赋值为普通类；而反之则不行。</p><p>这里继续提问，直接使用类作为类型，和使用<code>typeof 类</code>作为类型，有什么区别呢？</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * 定义一个类
 */</span>
<span class="token keyword">class</span> <span class="token class-name">People</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// p1可以正常赋值</span>
<span class="token keyword">const</span> p1<span class="token operator">:</span> People <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 等号后面的People报错，类型“typeof People”缺少类型“People”中的以下属性: name, age</span>
<span class="token keyword">const</span> p2<span class="token operator">:</span> People <span class="token operator">=</span> People<span class="token punctuation">;</span>

<span class="token comment">// p3报错，类型 &quot;People&quot; 中缺少属性 &quot;prototype&quot;，但类型 &quot;typeof People&quot; 中需要该属性</span>
<span class="token keyword">const</span> p3<span class="token operator">:</span> <span class="token keyword">typeof</span> People <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// p4可以正常赋值</span>
<span class="token keyword">const</span> p4<span class="token operator">:</span> <span class="token keyword">typeof</span> People <span class="token operator">=</span> People<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p><strong>结论是这样的：</strong></p><ul><li><p>当把<code>类</code>直接作为<code>类型</code>时，该类型约束的是该类型必须是<code>类的实例</code>；即该类型获取的是该类上的<code>实例属性</code>和<code>实例方法</code>（也叫<code>原型方法</code>）；</p></li><li><p>当把<code>typeof 类</code>作为类型时，约束的满足该类的类型；即该<code>类型</code>获取的是该类上的<code>静态属性和方法</code>。</p></li><li><p>最后，只需要对<code>infer</code>的使用换个位置，便可以获取构造函数返回值的类型：</p></li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">InstanceType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token keyword">abstract</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span></span> <span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token keyword">abstract</span></span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">infer</span> <span class="token constant">R</span> <span class="token operator">?</span> <span class="token constant">R</span> <span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="ts-compiler内部实现的类型" tabindex="-1"><a class="header-anchor" href="#ts-compiler内部实现的类型" aria-hidden="true">#</a> Ts compiler内部实现的类型</h3><ul><li>Uppercase</li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@desc</span> 构造一个将字符串转大写的类型
 * <span class="token keyword">@example</span>
 * type Eg1 = &#39;ABCD&#39;;
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg1</span> <span class="token operator">=</span> Uppercase<span class="token operator">&lt;</span><span class="token string">&#39;abcd&#39;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li>Lowercase</li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@desc</span> 构造一个将字符串转小大写的类型
 * <span class="token keyword">@example</span>
 * type Eg2 = &#39;abcd&#39;;
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg2</span> <span class="token operator">=</span> Lowercase<span class="token operator">&lt;</span><span class="token string">&#39;ABCD&#39;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li>Capitalize</li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@desc</span> 构造一个将字符串首字符转大写的类型
 * <span class="token keyword">@example</span>
 * type Eg3 = &#39;abcd&#39;;
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg3</span> <span class="token operator">=</span> Capitalize<span class="token operator">&lt;</span><span class="token string">&#39;Abcd&#39;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li>Uncapitalize</li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@desc</span> 构造一个将字符串首字符转小写的类型
 * <span class="token keyword">@example</span>
 * type Eg3 = &#39;ABCD&#39;;
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg3</span> <span class="token operator">=</span> Uncapitalize<span class="token operator">&lt;</span><span class="token string">&#39;aBCD&#39;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这些类型工具，在<code>lib.es5.d.ts</code>文件中是看不到具体定义的：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Uppercase<span class="token operator">&lt;</span><span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> intrinsic<span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Lowercase<span class="token operator">&lt;</span><span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> intrinsic<span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Capitalize<span class="token operator">&lt;</span><span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> intrinsic<span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Uncapitalize<span class="token operator">&lt;</span><span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> intrinsic<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="第三部分-自定义ts高级类型工具及类型编程技巧" tabindex="-1"><a class="header-anchor" href="#第三部分-自定义ts高级类型工具及类型编程技巧" aria-hidden="true">#</a> 第三部分 自定义Ts高级类型工具及类型编程技巧</h2><h3 id="symmetricdifference" tabindex="-1"><a class="header-anchor" href="#symmetricdifference" aria-hidden="true">#</a> SymmetricDifference</h3><p><code>SymmetricDifference&lt;T, U&gt;</code>获取没有同时存在于T和U内的类型。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * 核心实现
 */</span>
<span class="token keyword">type</span> <span class="token class-name">SymmetricDifference<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> SetDifference<span class="token operator">&lt;</span><span class="token constant">A</span> <span class="token operator">|</span> <span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">A</span> <span class="token operator">&amp;</span> <span class="token constant">B</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * SetDifference的实现和Exclude一样
 */</span>
<span class="token keyword">type</span> <span class="token class-name">SymmetricDifference<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> Exclude<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">|</span> <span class="token constant">U</span><span class="token punctuation">,</span> <span class="token constant">T</span> <span class="token operator">&amp;</span> <span class="token constant">U</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@example</span>
 * type Eg = &#39;1&#39; | &#39;4&#39;;
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> SymmetricDifference<span class="token operator">&lt;</span><span class="token string">&#39;1&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;2&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;3&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;2&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;3&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;4&#39;</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>其核心实现利用了3点：分发式联合类型、交叉类型和Exclude。</p><ul><li><p>首先利用<code>Exclude</code>从获取存在于第一个参数但是不存在于第二个参数的类型</p></li><li><p><code>Exclude</code>第2个参数是<code>T &amp; U</code>获取的是所有类型的交叉类型</p></li><li><p><code>Exclude</code>第一个参数则是<code>T | U</code>，这是利用在联合类型在<code>extends</code>中的分发特性，可以理解为<code>Exclude&lt;T, T &amp; U&gt; | Exclude&lt;U, T &amp; U&gt;</code>;</p></li></ul><p>总结一下就是，提取存在于<code>T</code>但不存在于<code>T &amp; U</code>的类型，然后再提取存在于<code>U</code>但不存在于<code>T &amp; U</code>的，最后进行联合。</p><h3 id="functionkeys" tabindex="-1"><a class="header-anchor" href="#functionkeys" aria-hidden="true">#</a> FunctionKeys</h3><p>获取<code>T</code>中所有类型为函数的<code>key</code>组成的联合类型。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@desc</span> NonUndefined判断T是否为undefined
 */</span>
<span class="token keyword">type</span> <span class="token class-name">NonUndefined<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token keyword">undefined</span></span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@desc</span> 核心实现
 */</span>
<span class="token keyword">type</span> <span class="token class-name">FunctionKeys<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> NonUndefined<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Function</span></span> <span class="token operator">?</span> <span class="token constant">K</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@example</span>
 * type Eg = &#39;key2&#39; | &#39;key3&#39;;
 */</span>
<span class="token keyword">type</span> <span class="token class-name">AType</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    key1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
    <span class="token function-variable function">key2</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">,</span>
    key3<span class="token operator">:</span> <span class="token builtin">Function</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> FunctionKeys<span class="token operator">&lt;</span>AType<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><ul><li><p>首先约束参数<code>T</code>类型为<code>object</code></p></li><li><p>通过映射类型<code>K in keyof T</code>遍历所有的key，先通过<code>NonUndefined&lt;T[K]&gt;</code>过滤<code>T[K]</code>为<code>undefined | null</code>的类型，不符合的返回<code>never</code></p></li><li><p>若<code>T[K]</code>为有效类型，则判断是否为<code>Function</code>类型，是的话返回<code>K</code>,否则<code>never</code>；此时可以得到的类型，例如：</p></li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * 上述的Eg在此时应该是如下类型，伪代码：
 */</span>
<span class="token keyword">type</span> <span class="token class-name">TempType</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    key1<span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">,</span>
    key2<span class="token operator">:</span> <span class="token string">&#39;key2&#39;</span><span class="token punctuation">,</span>
    key3<span class="token operator">:</span> <span class="token string">&#39;key3&#39;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>最后经过<code>{省略}[keyof T]</code>索引访问，取到的为值类型的联合类型<code>never | key2 | key3</code>,计算后就是<code>key2 | key3</code>;</li></ul><p><strong>注意 1</strong></p><ul><li><p><code>T[]</code>是索引访问操作，可以取到值的类型</p></li><li><p><code>T[&#39;a&#39; | &#39;b&#39;]</code>若<code>[]</code>内参数是联合类型，则也是分发索引的特性，依次取到值的类型进行联合</p></li><li><p><code>T[keyof T]</code>则是获取<code>T</code>所有值的类型类型；</p></li><li><p><code>never</code>和其他类型进行联合时，<code>never</code>是不存在的。例如：<code>never | number | string</code>等同于<code>number | string</code></p></li></ul><p><strong>注意 2</strong></p><ul><li><p><code>null</code>和<code>undefined</code>可以赋值给其他类型（开始该类型的严格赋值检测除外）,所以上述实现中需要使用<code>NonUndefined</code>先行判断。</p></li><li><p><code>NonUndefined</code>中的实现，只判断了<code>T extends undefined</code>，其实也是因为两者可以互相兼容的。所以你换成<code>T extends null</code>或者<code>T extends null | undefined</code>都是可以的。</p></li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// A = 1</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token keyword">undefined</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token keyword">null</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token comment">// B = 1</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token keyword">undefined</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>最后，如果你想写一个获取非函数类型的key组成的联合类型，无非就是<code>K</code>和<code>never</code>的位置不一样罢了。同样，你也可以实现<code>StringKeys</code>、<code>NumberKeys</code>等等。但是记得可以抽象个工厂类型：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Primitive</span> <span class="token operator">=</span>
  <span class="token operator">|</span> <span class="token builtin">string</span>
  <span class="token operator">|</span> <span class="token builtin">number</span>
  <span class="token operator">|</span> bigint
  <span class="token operator">|</span> <span class="token builtin">boolean</span>
  <span class="token operator">|</span> <span class="token builtin">symbol</span>
  <span class="token operator">|</span> <span class="token keyword">null</span>
  <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@desc</span> 用于创建获取指定类型工具的类型工厂
 * <span class="token keyword">@param</span> <span class="token parameter">T</span> 待提取的类型
 * <span class="token keyword">@param</span> <span class="token parameter">P</span> 要创建的类型
 * <span class="token keyword">@param</span> <span class="token parameter">IsCheckNon</span> 是否要进行null和undefined检查
 */</span>
<span class="token keyword">type</span> <span class="token class-name">KeysFactory<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">P</span> <span class="token keyword">extends</span> Primitive <span class="token operator">|</span> <span class="token builtin">Function</span> <span class="token operator">|</span> object<span class="token punctuation">,</span> IsCheckNon <span class="token keyword">extends</span> <span class="token builtin">boolean</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> IsCheckNon <span class="token keyword">extends</span> <span class="token class-name"><span class="token boolean">true</span></span>
    <span class="token operator">?</span> <span class="token punctuation">(</span>NonUndefined<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">P</span></span> <span class="token operator">?</span> <span class="token constant">K</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">P</span></span> <span class="token operator">?</span> <span class="token constant">K</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@example</span>
 * 例如上述KeysFactory就可以通过工厂类型进行创建了
 */</span>
<span class="token keyword">type</span> <span class="token class-name">FunctionKeys<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> KeysFactory<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token builtin">Function</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">StringKeys<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> KeysFactory<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">NumberKeys<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> KeysFactory<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h3 id="mutablekeys" tabindex="-1"><a class="header-anchor" href="#mutablekeys" aria-hidden="true">#</a> MutableKeys</h3><p><code>MutableKeys&lt;T&gt;</code>查找<code>T</code>所有可选类型的<code>key</code>组成的联合类型。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * 核心实现
 */</span>
<span class="token keyword">type</span> <span class="token class-name">MutableKeys<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">?</span><span class="token operator">:</span> IfEquals<span class="token operator">&lt;</span>
    <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">Q</span> <span class="token keyword">in</span> <span class="token constant">P</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span> <span class="token operator">-</span><span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">Q</span> <span class="token keyword">in</span> <span class="token constant">P</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token constant">P</span>
  <span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@desc</span> 一个辅助类型，判断X和Y是否类型相同，
 * <span class="token keyword">@returns</span> 是则返回A，否则返回B
 */</span>
<span class="token keyword">type</span> <span class="token class-name">IfEquals<span class="token operator">&lt;</span><span class="token constant">X</span><span class="token punctuation">,</span> <span class="token constant">Y</span><span class="token punctuation">,</span> <span class="token constant">A</span> <span class="token operator">=</span> <span class="token constant">X</span><span class="token punctuation">,</span> <span class="token constant">B</span> <span class="token operator">=</span> <span class="token builtin">never</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">X</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">Y</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token operator">?</span> <span class="token constant">A</span>
  <span class="token operator">:</span> <span class="token constant">B</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p><code>MutableKeys</code>还是有一定难度的，讲解<code>MutableKeys</code>的实现，我们要分下面几个步骤：</p><h4 id="第一步-先理解只读和非只读的一些特性" tabindex="-1"><a class="header-anchor" href="#第一步-先理解只读和非只读的一些特性" aria-hidden="true">#</a> 第一步，先理解只读和非只读的一些特性</h4><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * 遍历类型T，原封不动的返回，有点类似于拷贝类型的意思
 */</span>
<span class="token keyword">type</span> <span class="token class-name">RType1<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token doc-comment comment">/**
 * 遍历类型T，将每个key变成非只读
 * 或者理解成去掉只读属性更好理解。
 */</span>
<span class="token keyword">type</span> <span class="token class-name">RType2<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token operator">-</span><span class="token keyword">readonly</span><span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// R0 = { a: string; readonly b: number }</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">R0</span></span> <span class="token operator">=</span> RType1<span class="token operator">&lt;</span><span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token keyword">readonly</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>

<span class="token comment">// R1 = { a: string }</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">R1</span></span> <span class="token operator">=</span> RType1<span class="token operator">&lt;</span><span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token comment">// R2 = { a: string }</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">R2</span></span> <span class="token operator">=</span> RType2<span class="token operator">&lt;</span><span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token comment">// R3 = { readonly a: string }</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">R3</span></span> <span class="token operator">=</span> RType1<span class="token operator">&lt;</span><span class="token punctuation">{</span><span class="token keyword">readonly</span> a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token comment">// R4 = { a: string }</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">R4</span></span> <span class="token operator">=</span> RType2<span class="token operator">&lt;</span><span class="token punctuation">{</span><span class="token keyword">readonly</span> a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>可以看到：<code>RType1</code>和<code>RType2</code>的参数为<strong>非只读</strong>的属性时，<code>R1</code>和<code>R2</code>的结果是一样的；<code>RType1</code>和<code>RType2</code>的参数为<strong>只读</strong>的属性时，得到的结果<code>R3</code>是<strong>只读</strong>的，<code>R4</code>是<strong>非只读</strong>的。所以，这里要敲个重点了：</p><ul><li><p><code>[P in Keyof T]</code>是映射类型，而映射是同态的，同态即会拷贝原有的属性修饰符等。可以参考R0的例子。</p></li><li><p>映射类型上的<code>-readonly</code>表示为<strong>非只读</strong>，或者可以理解为去掉<strong>只读</strong>。对于<strong>只读</strong>属性加上<code>-readonly</code>变成了<strong>非只读</strong>，而对<code>非只读</code>属性加上<code>-readonly</code>后还是<strong>非只读</strong>。一种常见的使用方式，比如你想把属性变成都是非只读的，不能前面不加修饰符（虽然不写就表示非只读），但是要考虑到同态拷贝的问题。</p></li></ul><h4 id="第二步-解析ifequals" tabindex="-1"><a class="header-anchor" href="#第二步-解析ifequals" aria-hidden="true">#</a> 第二步，解析IfEquals</h4><p><code>IfEquals</code>用于判断类型<code>X</code>和<code>Y</code>是否相同，相等则返回<code>A</code>，否则返回<code>B</code>。这个函数是比较难的，也别怕啦，下面讲完就妥妥的明白啦~</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">IfEquals<span class="token operator">&lt;</span><span class="token constant">X</span><span class="token punctuation">,</span> <span class="token constant">Y</span><span class="token punctuation">,</span> <span class="token constant">A</span> <span class="token operator">=</span> <span class="token constant">X</span><span class="token punctuation">,</span> <span class="token constant">B</span> <span class="token operator">=</span> <span class="token builtin">never</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span>
  <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">X</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">extends</span>
  <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">Y</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token operator">?</span> <span class="token constant">A</span> <span class="token operator">:</span> <span class="token constant">B</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><p>首先<code>IfEquals&lt;X, Y, A, B&gt;</code>的四个参数，<code>X和Y</code>是待比较的两个类型，如果相等则返回<code>A</code>，不相等返回<code>B</code>。</p></li><li><p><code>IfEquals</code>的基本骨架是<code>type IfEquals&lt;&gt; = (参数1) extends (参数2) ? A : B</code>这样的，就是判断如果参数1的类型能够分配给参数2的类型，则返回<code>A</code>，否则返回<code>B</code>;</p></li><li><p>参数1和参数2的基本结构是一样的，唯一区别在于X和Y不同。这里看下具体下面的例子：</p></li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// A = &lt;T&gt;() =&gt; T extends string ? 1 : 2;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token comment">// B = &lt;T&gt;() =&gt; T extends number ? 1 : 2;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token comment">// C = 2</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token operator">=</span> <span class="token constant">A</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>是不是很奇怪，为什么能推导出<code>A</code>和<code>B</code>类型是不一样的？告诉你答案：</p><ul><li><p>这是利用了Ts编译器的一个特点，就是Ts编译器会认为如果两个类型（比如这里的<code>X</code>和<code>Y</code>）仅被用于约束两个相同的泛型函数则是相同的。这理解起来有些不可思议，或者说在逻辑上这种逻辑并不对（因为可以举出反例），但是Ts开发团队保证了这一特性今后不会变。</p></li><li><p>注意，这里也会判断的属性修饰符，例如<code>readonly</code>, <code>可选属性</code>等，看通过下面的例子验证：</p></li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * T2比T1多了readonly修饰符
 * T3比T1多了可选修饰符
 * 这里控制单一变量进行验证
 */</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>key1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token keyword">readonly</span> key1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T3</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>key1<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// A1 = false</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A1</span></span> <span class="token operator">=</span> IfEquals<span class="token operator">&lt;</span><span class="token constant">T1</span><span class="token punctuation">,</span> <span class="token constant">T2</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token comment">// A2 = false</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A2</span></span> <span class="token operator">=</span> IfEquals<span class="token operator">&lt;</span><span class="token constant">T1</span><span class="token punctuation">,</span> <span class="token constant">T3</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><ul><li><code>IfEquals</code>最后就是借助1和2来辅助判断（语法层面的），还有就是给<code>A</code>的默认值为<code>X</code>，<code>B</code>的默认值为<code>never</code>。</li></ul><p><strong>关键问题</strong></p><blockquote><p>判断类型是否相等（兼容）为什么不直接使用<code>type IfEquals&lt;X, Y, A, B&gt; = X extends Y ? A : B</code></p></blockquote><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">IfEquals<span class="token operator">&lt;</span><span class="token constant">X</span><span class="token punctuation">,</span> <span class="token constant">Y</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">X</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">Y</span></span> <span class="token operator">?</span> <span class="token constant">A</span> <span class="token operator">:</span> <span class="token constant">B</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * 还用上面的例子
 */</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>key1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token keyword">readonly</span> key1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T3</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>key1<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// A1 = true</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A1</span></span> <span class="token operator">=</span> IfEquals<span class="token operator">&lt;</span><span class="token constant">T1</span><span class="token punctuation">,</span> <span class="token constant">T2</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token comment">// A2 = true</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A2</span></span> <span class="token operator">=</span> IfEquals<span class="token operator">&lt;</span><span class="token constant">T1</span><span class="token punctuation">,</span> <span class="token constant">T3</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="第3步-解析mutablekeys实现逻辑" tabindex="-1"><a class="header-anchor" href="#第3步-解析mutablekeys实现逻辑" aria-hidden="true">#</a> 第3步，解析MutableKeys实现逻辑</h4><ul><li><p><code>MutableKeys</code>首先约束<code>T</code>为<code>object</code>类型</p></li><li><p>通过映射类型<code>[P in keyof T]</code>进行遍历，key对应的值则是<code>IfEquals&lt;类型1, 类型2, P&gt;</code>，如果类型1和类型2相等则返回对应的<code>P</code>（也就是<code>key</code>），否则返回<code>never</code>。</p></li></ul><p>而<code>P</code>其实就是一个只有一个当前key的联合类型，所以<code>[Q in P]: T[P]</code>也只是一个普通的映射类型。但是要注意的是参数1<code>{ [Q in P]: T[P] }</code>是通过<code>{}</code>构造的一个类型，参数2<code>{ -readonly [Q in P]: T[P] }</code>也是通过<code>{}</code>构造的一个类型,两者的唯一区别即使<code>-readonly</code>。</p><p>所以这里就有意思了，回想一下上面的第一步的例子，是不是就理解了：如果<code>P</code>是只读的，那么参数1和参数2的<code>P</code>最终都是只读的；如果<code>P</code>是非只读的，则参数1的<code>P</code>为非只读的，而参数2的<code>P</code>被<code>-readonly</code>去掉了非只读属性从而变成了只读属性。因此就完成了筛选：<code>P</code>为非只读时<code>IfEquals</code>返回的<code>P</code>，<code>P</code>为只读时<code>IfEquals</code>返回<code>never</code>。</p><ul><li>所以<code>key</code>为非只读时，类型为<code>key</code>，否则类型为<code>never</code>，最后通过<code>[keyof T]</code>得到了所有<code>非只读key</code>的联合类型。</li></ul><h3 id="optionalkeys" tabindex="-1"><a class="header-anchor" href="#optionalkeys" aria-hidden="true">#</a> OptionalKeys</h3><p><code>OptionalKeys&lt;T&gt;</code>提取T中所有可选类型的key组成的联合类型。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">OptionalKeys<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">extends</span> <span class="token class-name">Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">P</span><span class="token operator">&gt;</span></span> <span class="token operator">?</span> <span class="token constant">P</span> <span class="token operator">:</span> <span class="token builtin">never</span>
<span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> OptionalKeys<span class="token operator">&lt;</span><span class="token punctuation">{</span>key1<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> key2<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li><p>核心实现，用映射类型遍历所有key，通过<code>Pick&lt;T, P&gt;</code>提取当前<code>key</code>和<code>类型</code>。注意，这里也是利用了<code>同态拷贝会拷贝可选修饰符的特性</code>。</p></li><li><p>利用<code>{} extends {当前key: 类型}</code>判断是否是可选类型。</p></li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// Eg2 = false</span>
<span class="token keyword">type</span> <span class="token class-name">Eg2</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span>key1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token comment">// Eg3 = true</span>
<span class="token keyword">type</span> <span class="token class-name">Eg3</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span>key1<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>利用的就是<code>{}</code>和只包含可选参数类型<code>{key?: string}</code>是兼容的这一特性。把<code>extends</code>前面的<code>{}</code>替换成<code>object</code>也是可以的。</p><h3 id="增强pick" tabindex="-1"><a class="header-anchor" href="#增强pick" aria-hidden="true">#</a> 增强Pick</h3><ul><li>PickByValue提取指定值的类型</li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// 辅助函数，用于获取T中类型不能never的key组成的联合类型</span>
<span class="token keyword">type</span> <span class="token class-name">TypeKeys<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * 核心实现
 */</span>
<span class="token keyword">type</span> <span class="token class-name">PickByValue<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span>
  TypeKeys<span class="token operator">&lt;</span><span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">V</span></span> <span class="token operator">?</span> <span class="token constant">P</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@example</span>
 *  type Eg = <span class="token punctuation">{</span>
 *    key1: number;
 *    key3: number;
 *  <span class="token punctuation">}</span>
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> PickByValue<span class="token operator">&lt;</span><span class="token punctuation">{</span>key1<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> key2<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> key3<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>Ts的类型兼容特性，所以类似<code>string</code>是可以分配给<code>string | number</code>的，因此上述并不是精准的提取方式。如果实现精准的方式，则可以考虑下面个这个类型工具。</p><ul><li>PickByValueExact精准的提取指定值的类型</li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * 核心实现
 */</span>
<span class="token keyword">type</span> <span class="token class-name">PickByValueExact<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span>
  TypeKeys<span class="token operator">&lt;</span><span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token constant">V</span><span class="token punctuation">]</span>
    <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token constant">V</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token constant">P</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;</span>

<span class="token comment">// type Eg1 = { b: number };</span>
<span class="token keyword">type</span> <span class="token class-name">Eg1</span> <span class="token operator">=</span> PickByValueExact<span class="token operator">&lt;</span><span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">&gt;</span>
<span class="token comment">// type Eg2 = { b: number; c: number | undefined }</span>
<span class="token keyword">type</span> <span class="token class-name">Eg2</span> <span class="token operator">=</span> PickByValueExact<span class="token operator">&lt;</span><span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> c<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><code>PickByValueExact</code>的核心实现主要有三点：</p><p>一是利用<code>Pick</code>提取我们需要的<code>key</code>对应的类型</p><p>二是利用给泛型套一层元组规避<code>extends</code>的<strong>分发式联合类型</strong>的特性</p><p>三是利用两个类型互相兼容的方式判断是否相同。</p><p>具体可以看下下面例子：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Eq1<span class="token operator">&lt;</span><span class="token constant">X</span><span class="token punctuation">,</span> <span class="token constant">Y</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">X</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">Y</span></span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Eq2<span class="token operator">&lt;</span><span class="token constant">X</span><span class="token punctuation">,</span> <span class="token constant">Y</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">X</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token constant">Y</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Eq3<span class="token operator">&lt;</span><span class="token constant">X</span><span class="token punctuation">,</span> <span class="token constant">Y</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">X</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token constant">Y</span><span class="token punctuation">]</span>
  <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token constant">Y</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token constant">X</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
  <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

<span class="token comment">// boolean, 期望是false</span>
<span class="token keyword">type</span> <span class="token class-name">Eg1</span> <span class="token operator">=</span> Eq1<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token operator">&gt;</span>
<span class="token comment">// false</span>
<span class="token keyword">type</span> <span class="token class-name">Eg2</span> <span class="token operator">=</span> Eq2<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token operator">&gt;</span>

<span class="token comment">// true，期望是false</span>
<span class="token keyword">type</span> <span class="token class-name">Eg3</span> <span class="token operator">=</span> Eq2<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">&gt;</span>
<span class="token comment">// false</span>
<span class="token keyword">type</span> <span class="token class-name">Eg4</span> <span class="token operator">=</span> Eq3<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">&gt;</span>

<span class="token comment">// true，非strictNullChecks模式下的结果</span>
<span class="token keyword">type</span> <span class="token class-name">Eg5</span> <span class="token operator">=</span> Eq3<span class="token operator">&lt;</span><span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">&gt;</span>
<span class="token comment">// false，strictNullChecks模式下的结果</span>
<span class="token keyword">type</span> <span class="token class-name">Eg6</span> <span class="token operator">=</span> Eq3<span class="token operator">&lt;</span><span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><ul><li><p>从<code>Eg1</code>和<code>Eg2</code>对比可以看出，给<code>extends</code>参数套上元组可以避免分发的特性，从而得到期望的结果；</p></li><li><p>从<code>Eg3</code>和<code>Eg4</code>对比可以看出，通过判断两个类型互相是否兼容的方式，可以得到从属类型的正确相等判断。</p></li><li><p>从<code>Eg5</code>和<code>Eg6</code>对比可以看出，非<code>strictNullChecks</code>模式下，<code>undefined</code>和<code>null</code>可以赋值给其他类型的特性，导致<code>number | undefined</code>, <code>number</code>是兼容的，因为是非<code>strictNullChecks</code>模式，所以有这个结果也是符合预期。如果不需要此兼容结果，完全可以开启<code>strictNullChecks</code>模式。</p></li></ul><p>最后，同理想得到<code>OmitByValue</code>和<code>OmitByValueExact</code>基本一样的思路就不多说了，大家可以自己思考实现。</p><h3 id="intersection" tabindex="-1"><a class="header-anchor" href="#intersection" aria-hidden="true">#</a> Intersection</h3><p><code>Intersection&lt;T, U&gt;</code>从<code>T</code>中提取存在于<code>U</code>中的<code>key</code>和对应的类型。（注意，最终是从<code>T</code>中提取<code>key</code>和类型）</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * 核心思路利用Pick提取指定的key组成的类型
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Intersection<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span> <span class="token constant">U</span> <span class="token keyword">extends</span> object<span class="token operator">&gt;</span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span>
  Extract<span class="token operator">&lt;</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token keyword">keyof</span> <span class="token constant">U</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span> Extract<span class="token operator">&lt;</span><span class="token keyword">keyof</span> <span class="token constant">U</span><span class="token punctuation">,</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;</span>

<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> Intersection<span class="token operator">&lt;</span><span class="token punctuation">{</span>key1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>key1<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">,</span> key2<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li><p>约束<code>T</code>和<code>U</code>都是<code>object</code>，然后利用<code>Pick</code>提取指定的<code>key</code>组成的类型</p></li><li><p>通过<code>Extract&lt;keyof T, keyof U&gt;</code>提取同时存在于<code>T</code>和<code>U</code>中的<code>key</code>，<code>Extract&lt;keyof U, keyof T&gt;</code>也是同样的操作</p></li></ul><p>那么为什么要做<strong>2</strong>次<code>Extract</code>然后再交叉类型呢？原因还是在于处理类型的兼容推导问题，还记得<code>string</code>可分配给<code>string | number</code>的兼容吧。</p><p><strong>扩展：</strong></p><p>定义<code>Diff&lt;T, U&gt;</code>，从<code>T</code>中排除存在于<code>U</code>中的key和类型。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Diff<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span> <span class="token constant">U</span> <span class="token keyword">extends</span> object<span class="token operator">&gt;</span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span>
  <span class="token constant">T</span><span class="token punctuation">,</span>
  Exclude<span class="token operator">&lt;</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token keyword">keyof</span> <span class="token constant">U</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="overwrite-和-assign" tabindex="-1"><a class="header-anchor" href="#overwrite-和-assign" aria-hidden="true">#</a> Overwrite 和 Assign</h3><p><code>Overwrite&lt;T, U&gt;</code>从<code>U</code>中的同名属性的类型覆盖<code>T</code>中的同名属性类型。(后者中的同名属性覆盖前者)</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * Overwrite实现
 * 获取前者独有的key和类型，再取两者共有的key和该key在后者中的类型，最后合并。
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Overwrite<span class="token operator">&lt;</span>
  <span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span>
  <span class="token constant">U</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span>
  <span class="token constant">I</span> <span class="token operator">=</span> Diff<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span> Intersection<span class="token operator">&lt;</span><span class="token constant">U</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;</span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span><span class="token constant">I</span><span class="token punctuation">,</span> <span class="token keyword">keyof</span> <span class="token constant">I</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@example</span>
 * type Eg1 = <span class="token punctuation">{</span> key1: number; <span class="token punctuation">}</span>
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg1</span> <span class="token operator">=</span> Overwrite<span class="token operator">&lt;</span><span class="token punctuation">{</span>key1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>key1<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> other<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><ul><li><p>首先约束<code>T</code>和<code>U</code>这两个参数都是<code>object</code></p></li><li><p>借助一个参数<code>I</code>的默认值作为实现过程，使用的时候不需要传递I参数（只是辅助实现的）</p></li><li><p>通过<code>Diff&lt;T, U&gt;</code>获取到存在于<code>T</code>但是不存在于<code>U</code>中的key和其类型。（即获取<code>T</code>自己特有<code>key</code>和类型）。</p></li><li><p>通过<code>Intersection&lt;U, T&gt;</code>获取<code>U</code>和<code>T</code>共有的<code>key</code>已经该key在<code>U</code>中的类型。即获取后者同名<code>key</code>已经类型。</p></li><li><p>最后通过交叉类型进行合并，从而曲线救国实现了覆盖操作。</p></li></ul><p>扩展：如何实现一个<code>Assign&lt;T, U&gt;</code>（类似于<code>Object.assign()</code>）用于合并呢？</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// 实现</span>
<span class="token keyword">type</span> <span class="token class-name">Assign<span class="token operator">&lt;</span>
  <span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span>
  <span class="token constant">U</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span>
  <span class="token constant">I</span> <span class="token operator">=</span> Diff<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span> Intersection<span class="token operator">&lt;</span><span class="token constant">U</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span> Diff<span class="token operator">&lt;</span><span class="token constant">U</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;</span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span><span class="token constant">I</span><span class="token punctuation">,</span> <span class="token keyword">keyof</span> <span class="token constant">I</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@example</span>
 * type Eg = <span class="token punctuation">{</span>
 *   name: string;
 *   age: string;
 *   other: string;
 * <span class="token punctuation">}</span>
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> Assign<span class="token operator">&lt;</span>
  <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> age<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> other<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>想一下，是不是就是先找到前者独有的<code>key</code>和<code>类型</code>，再找到两者共有的key以及该<code>key</code>在后者中的<code>类型</code>，最后找到后者独有的<code>key</code>和<code>类型</code>，最后依次的合并进去。</p><h3 id="deeprequired" tabindex="-1"><a class="header-anchor" href="#deeprequired" aria-hidden="true">#</a> DeepRequired</h3><p><code>DeepRequired&lt;T&gt;</code>将<code>T</code>的转换成必须属性。如果<code>T</code>为对象，则将递归对象将所有<code>key</code>转换成<code>required</code>，类型转换为<code>NonUndefined</code>；如果<code>T</code>为数组则递归遍历数组将每一项设置为<code>NonUndefined</code>。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * DeepRequired实现
 */</span>
<span class="token keyword">type</span> <span class="token class-name">DeepRequired<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">any</span>
  <span class="token operator">?</span> <span class="token constant">T</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span></span>
    <span class="token operator">?</span> _DeepRequiredArray<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>
    <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">object</span>
      <span class="token operator">?</span> _DeepRequiredObject<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span>
      <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

<span class="token comment">// 辅助工具，递归遍历数组将每一项转换成必选</span>
<span class="token keyword">interface</span> <span class="token class-name">_DeepRequiredArray<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Array</span><span class="token operator">&lt;</span>DeepRequired<span class="token operator">&lt;</span>NonUndefined<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;&gt;</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 辅助工具，递归遍历对象将每一项转换成必选</span>
<span class="token keyword">type</span> <span class="token class-name">_DeepRequiredObject<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">?</span><span class="token operator">:</span> DeepRequired<span class="token operator">&lt;</span>NonUndefined<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><ul><li><p><code>DeepRequired</code>利用<code>extends</code>判断如果是函数或<code>Primitive</code>的类型，就直接返回该类型。</p></li><li><p>如果是数组类型，则借助<code>_DeepRequiredArray</code>进行递归，并且传递的参数为数组所有子项类型组成的联合类型，如下：</p></li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span>
<span class="token doc-comment comment">/**
 * <span class="token keyword">@description</span> 对数组进行number索引访问，
 * 得到的是所有子项类型组成的联合类型
 * type B = string | number
 */</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> <span class="token constant">A</span><span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li><p><code>_DeepRequiredObject</code>是个接口（定义成type也可以），其类型是<code>Array&lt;T&gt;</code>；而此处的<code>T</code>则通过<code>DeepRequired&lt;T&gt;</code>进行对每一项进行递归；在<code>T</code>被使用之前，先被<code>NonUndefined&lt;T&gt;</code>处理一次，去掉无效类型。</p></li><li><p>如果是对象类型，则借助<code>_DeepRequiredObject</code>实现对象的递归遍历。<code>_DeepRequiredObject</code>只是一个普通的映射类型进行变量，然后对每个key添加<code>-?</code>修饰符转换成<code>required</code>类型。</p></li></ul><h3 id="deepreadonlyarray" tabindex="-1"><a class="header-anchor" href="#deepreadonlyarray" aria-hidden="true">#</a> DeepReadonlyArray</h3><p><code>DeepReadonlyArray&lt;T&gt;</code>将<code>T</code>的转换成只读的，如果<code>T</code>为<code>object</code>则将所有的<code>key</code>转换为只读的，如果<code>T</code>为数组则将数组转换成只读数组。整个过程是深度递归的。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * DeepReadonly实现
 */</span>
<span class="token keyword">type</span> <span class="token class-name">DeepReadonly<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">|</span> Primitive
  <span class="token operator">?</span> <span class="token constant">T</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">_DeepReadonlyArray<span class="token operator">&lt;</span><span class="token keyword">infer</span> <span class="token constant">U</span><span class="token operator">&gt;</span></span>
  <span class="token operator">?</span> _DeepReadonlyArray<span class="token operator">&lt;</span><span class="token constant">U</span><span class="token operator">&gt;</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">_DeepReadonlyObject<span class="token operator">&lt;</span><span class="token keyword">infer</span> <span class="token constant">V</span><span class="token operator">&gt;</span></span>
  <span class="token operator">?</span> _DeepReadonlyObject<span class="token operator">&lt;</span><span class="token constant">V</span><span class="token operator">&gt;</span>
  <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * 工具类型，构造一个只读数组
 */</span>
<span class="token keyword">interface</span> <span class="token class-name">_DeepReadonlyArray<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">ReadonlyArray<span class="token operator">&lt;</span>DeepReadonly<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * 工具类型，构造一个只读对象
 */</span>
<span class="token keyword">type</span> <span class="token class-name">_DeepReadonlyObject<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> DeepReadonly<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><ul><li>基本实现原理和<code>DeepRequired</code>一样，但是注意<code>infer U</code>自动推导数组的类型，<code>infer V</code>推导对象的类型。</li></ul><h3 id="uniontointersection" tabindex="-1"><a class="header-anchor" href="#uniontointersection" aria-hidden="true">#</a> UnionToIntersection</h3><p>将联合类型转变成交叉类型。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">UnionToIntersection<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span>
  <span class="token operator">?</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>
  <span class="token operator">:</span> <span class="token builtin">never</span>
<span class="token punctuation">)</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">U</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span> <span class="token operator">?</span> <span class="token constant">U</span> <span class="token operator">:</span> <span class="token builtin">never</span>
<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> UnionToIntersection<span class="token operator">&lt;</span><span class="token punctuation">{</span> key1<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span> <span class="token operator">|</span> <span class="token punctuation">{</span> key2<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li><p><code>T extends any ? (arg: T) =&gt; void : never</code>该表达式一定走true分支，用此方式构造一个逆变的联合类型<code>(arg: T1) =&gt; void | (arg: T2) =&gt; void | (arg: Tn) =&gt; void</code></p></li><li><p>再利用第二个<code>extends</code>配合<code>infer</code>推导得到U的类型，但是利用<code>infer</code>对<strong>协变类型的特性得到交叉类型</strong>。</p></li></ul><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: suiyi19920228@qq.com">sykinggg</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/technology/ts/project/unknownAny.html" class="" aria-label="TypeScript 中 unknown 与 any 有啥区别"><!--[--><!--]--> TypeScript 中 unknown 与 any 有啥区别 <!--[--><!--]--></a></span><span class="next"><a href="/technology/ts/project/compilationContext.html" class="" aria-label="编译上下文"><!--[--><!--]--> 编译上下文 <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/technology/assets/app.ee3fc36b.js" defer></script>
  </body>
</html>
